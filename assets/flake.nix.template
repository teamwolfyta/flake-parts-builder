# --- flake.nix
{
  description = "practicalFlakes - TODO Add a description of your new project";

  inputs = {
    # --- BASE DEPENDENCIES ---
    nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";
    systems.url = "github:nix-systems/default";

    # --- (YOUR) EXTRA DEPENDENCIES ---

{ extra_flake_inputs }
  };

  # NOTE Here you can add additional binary cache substituers that you trust.
  # There are also some sensible default caches commented out that you
  # might consider using.
  nixConfig = {
    extra-trusted-public-keys = [
      # "cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY="
      # "nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs="
{ extra_trused_public_keys }
    ];
    extra-substituters = [
      # "https://cache.nixos.org"
      # "https://nix-community.cachix.org/"
{ extra_substituters }
    ];
  };

  outputs =
    inputs@{ flake-parts, ... }:
    let
      inherit (inputs.nixpkgs) lib;

      flatten = attrs: lib.collect (x: !lib.isAttrs x) attrs;

      mapFilterAttrs =
        pred: f: attrs:
        lib.filterAttrs pred (lib.mapAttrs' f attrs);

      mapModules =
        dir: fn:
        mapFilterAttrs (n: v: v != null && !(lib.hasPrefix "_" n) && !(lib.lib.hasPrefix ".git" n)) (
          n: v:
          let
            path = "${toString dir}/${n}";
          in
          if v == "directory" && builtins.pathExists "${path}/default.nix" then
            lib.nameValuePair n (fn path)
          else if v == "directory" then
            lib.nameValuePair n (mapModules path fn)
          else if v == "regular" && n != "default.nix" && lib.hasSuffix ".nix" n then
            lib.nameValuePair (lib.removeSuffix ".nix" n) (fn path)
          else
            lib.nameValuePair "" null
        ) (builtins.readDir dir);
    in
    flake-parts.lib.mkFlake { inherit inputs; } {
      # We recursively traverse all of the flakeModules in ./parts and import only
      # the final modules, meaning that you can have an arbitrary nested structure
      # that suffices your needs. For example
      #
      # - ./parts
      #   - modules/
      #     - nixos/
      #       - myNixosModule1.nix
      #       - myNixosModule2.nix
      #       - default.nix
      #     - home-manager/
      #       - myHomeModule1.nix
      #       - myHomeModule2.nix
      #       - default.nix
      #     - sharedModules.nix
      #    - pkgs/
      #      - myPackage1.nix
      #      - myPackage2.nix
      #      - default.nix
      #    - mySimpleModule.nix
      imports = flatten (mapModules ./parts (x: x));

      # NOTE We use the default `systems` defined by the `nix-systems` flake, if
      # you need any additional systems, simply add them in the following manner
      #
      # `systems = (import inputs.systems) ++ [ "armv7l-linux" ];`
      systems = import inputs.systems;
    };
}
